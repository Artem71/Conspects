Разница между транспиляцией и компиляцией в том, что последняя преобразовывает исходный код программы в машинный байт-код,
в то время как транспиляция конвертирует программу из одного языка в другой (например, из TypeScript в JavaScript).
Однако в сообществе TypeScript все же более распространен термин компиляция.

unknown — аналог any, с которым нельзя производить никаких действий, не утвердив или сузив его до более конкретного типа;

never — для представления невозможного кода (вскоре будет приведен пример);

void — отсутствие значения.

В отличие от типа never, функция void завершает свое выполнение, но не возвращает значение.

Следует избегать явных аннотаций типов там, где компилятор TypeScript сможет вывести их сам:
```
let name2: string = 'John Smith'; - Избыточно
let name1 = 'John Smith'; - Нормас
```

Если вы объявляете переменную, не инициализируя ее с конкретным значением, TypeScript использует внутренние типы null
или undefined, которые преобразуются в any. Это называется расширением типов.

Попытка применить условные инструкции для уточнения типа переменной называется сужением типа.

Различие между typeof и instanceof состоит в том, что первая используется со встроенными типами, а последняя — с 
пользовательскими.

```
if (person instanceof Person) {...}
if (typeof padding === "string") {...}
```

TypeScript и некоторые другие языки используют структурную систему типов.

Защита типа in действует как сужающее выражение для типов. Например, если у вас есть функция, которая может получать
аргумент объединенного типа, то вы можете проверить фактический тип, заданный во время вызова функции.

Если вы объявите переменную типа unknown, компилятор вынудит сузить ее тип прежде, чем позволит обращаться к ее
свойствам, спасая тем самым от возможных сюрпризов в среде выполнения.

- Несмотря на то что объявление типов переменных вынуждает разработчиков писать больше кода, их продуктивность растет в
долгосрочной перспективе.
- TypeScript предлагает ряд аннотаций типов, но можно также объявлять пользовательские.
- Можно создавать новые типы, объявляя объединение существующих.
- TypeScript использует структурную систему типов в противоположность Java или C#, которые используют номинальную.

В версии ES6, когда свойство должно быть совместно использовано каждым экземпляром класса, мы можем объявить его как static

> Приватный конструктор препятствует инстанцированию с оператором new

Если вы добавите ключевое слово abstract в объявление класса, то он не сможет быть инстанцирован. Абстрактный класс
может включать как методы, которые были реализованы, так и те, что были только объявлены.
Зачем вам может понадобиться создавать класс, не допускающий инстанцирования? Вы можете захотеть делегировать реализацию
некоторых методов его подклассам и убедиться, что эти методы будут иметь конкретные сигнатуры.

Объектно-ориентированные языки вроде Java и C# поддерживают перегрузку методов. Это означает, что класс может объявлять
более одного метода с одним именем, но разными аргументами. Например, вы можете написать две версии метода calculateTax():
одну с двумя аргументами, такими как доход гражданина и количество иждивенцев, а вторую с одним аргументом типа Customer,
содержащим все нужные данные этого гражданина.

зачем вообще объявлять перегруженные сигнатуры, если вы можете просто реализовать один метод, используя объединения в
типах аргументов и возвращаемых значениях? Перегрузка методов помогает компилятору TypeScript правильно отобразить
переданные типы аргументов в типы возвращаемых значений. Когда перегруженные сигнатуры методов объявлены, статический
анализатор верно предположит способы вызова перегруженного метода.
При перегрузке метода или конструктора в TypeScript прислушивайтесь к здравому смыслу. Несмотря на то что перегрузка
обеспечивает несколько способов вызова метода, его логика может легко стать непонятной. В нашей современной работе в
TypeScript мы редко пользуемся перегрузкой.

> Программируйте через интерфейсы, а не через реализации

> Вы можете создавать класс, взяв за основу другой. Мы называем это наследованием класса.

#### Перечисления и обобщенные типы

Перечисления позволяют создавать ограниченные наборы именованных констант, имеющих что-то общее. Такие константы могут
быть числами или строками.

```
enum Weekdays {
  Monday = 1,
  Tuesday = 2,
  Wednesday = 3,
  Thursday = 4,
  Friday = 5,
  Saturday = 6,
  Sunday = 7
}

const dayOff = Weekdays.Tuesday;
```
Использование членов перечисления Weekdays не дает допустить ошибку и присвоить переменной dayOff неверное значение
(например, 8).

> Если вы знаете значение численного enum, то можете найти имя члена этого enum. `console.log(Weekdays[3]); // Wednesday`

Еще реальный кейс использования: для передачи как аргумента в функцию с ограниченным вариантом параметров:
```
enum Direction {
  from, to
}

convert(Direction.from)

function convert (dir: Direction) {
  return dir === Direction.from ? // some logic : // another logic
}
```

Если вы используете ключевое слово const при объявлении enum, то его значения будут встроены и код JavaScript
сгенерирован НЕ будет. (без const будет и в js)

##### Обобщения
Обобщение — это часть кода, способная обрабатывать значения нескольких типов, которые указываются при использовании 
этого кода (в процессе вызова функции или инстанцирования класса).

В то время как Java и C# используют номинальную систему типов, TypeScript использует структурную.
В номинальной системе типов типы проверяются по их именам, но в структурной определение происходит согласно их структуре.
В структурной системе типов вы можете присваивать объект одного типа переменной другого типа до тех пор, пока структуры
этих типов будут одинаковы.

Обобщения могут использоваться в различных сценариях. Например, вы можете создать функцию, получающую значения разных 
типов, но в процессе ее вызова вы должны указать конкретный тип. Чтобы использовать обобщения с классом, интерфейсом 
или функцией, этот класс, интерфейс или функция должны быть написаны особым образом, чтобы поддерживать обобщенные типы.

Если вы не освоили принцип программирования через интерфейсы (объясненный в разделе 3.2.3), то можете просто добавить в 
класс Rectangle метод compareRectangles().
Однако вооружившись принципом программирования через интерфейсы, вы будете мыслить иначе: «Сегодня мне нужно сравнить 
прямоугольники, а завтра они попросят меня сравнить другие объекты. Я проявлю находчивость и объявлю интерфейс с 
функцией compareTo(). Тогда класс Rectangle и любой другой класс в будущем сможет реализовать этот интерфейс. Алгоритмы
сравнивания прямоугольников будут отличаться от сравнивания, скажем, треугольников, но по крайней мере у них будет 
что-то общее, а сигнатура метода compareTo() будет выглядеть одинаковой».
```
interface Comparator<T> {
  compareTo(value: T): number;
}
```

Если функция может получать функцию в качестве аргумента или возвращать другую функцию, мы называем ее функцией высшего
порядка.
---

#### Декораторы и продвинутые типы

> В документации TS декоратор — особый вид объявления, который может быть прикреплен к объявлению класса, метода, 
> аксессора, свойства или параметра. Декораторы используют форму @expression, где выражение должно вычисляться в функцию, 
> которая будет вызвана при выполнении с информацией о декорированном объявлении1.

Мы можем также сказать, что декоратор добавляет метаданные конкретной цели (цель - то, к чему применяем декоратор)

Декораторы (в отличие от наследования) разделяют задачи и облегчают обслуживание кода, поскольку фреймворк (ангуляр) 
волен интерпретировать их по своему усмотрению.

##### Создание декораторов классов
Этот вид декораторов применяется к классу, а функция декоратора выполняется при выполнении конструктора. Для их 
реализации необходим один параметр — функция — конструктор класса. Другими словами, декоратор класса будет получать
функцию — конструктор декорируемого класса.

В JS примесь (миксин) — это часть кода, реализующая конкретное поведение. Примеси не используются отдельно, но их 
поведение может быть добавлено другим классам. Хотя JS не поддерживает множественное наследование, вы можете совместить
поведения из нескольких классов, используя примеси.

```
function useSalutation(salutation: string) {                 // Функция-фабрика (декораторов) принимает строку с приветствием
  return function <T extends constructorMixin> (target: T) { // Возвращает декоратор для класса
    return class extends target {                            // Декоратор подменяет класс возвращая новый (расширяя старый)
      name: string;                                          // Дублирует свойство родителя
      private message = 'Hello ' + salutation + this.name;   // Добавляет новое свойство

      sayHello() {                                           // Заменяет метод родителя (новое поведение)
        console.log(`${this.message}`);
      }
    }
  }
}

@useSalutation("Mr. ") // Применяет к классу декоратор с аргументом
class Greeter {}
```

##### Создание декораторов методов

Функция MethodDecorator требует три параметра:
- target — объект, ссылающийся на созданный экземпляр класса, определяющего метод;
- propertyKey — имя декорируемого метода;
- descriptor — дескриптор декорируемого метода.

Параметр descriptor содержит объект, описывающий метод, декорируемый вашим кодом. Говоря конкретнее, 
TypedPropertyDescriptor имеет свойство value, хранящее оригинальный код декорированного метода. Изменяя значение этого 
свойства внутри декоратора метода, вы можете модифицировать оригинальный код декорируемого метода.

```
function logTrade(target, key, descriptor) {             // Декоратор метода должен иметь 3 аргумента
  const originalCode = descriptor.value;                 // Оригинальный код метода

  descriptor.value = function () {                       // Изменяет код декорируемого метода
    console.log(`Invoked ${key} providing:`, arguments); // Добавляем функционал
    return originalCode.apply(this, arguments);          // Вызывает оригинальный метод
  };

  return descriptor;                                     // Возвращаем измененный метод
}
```

##### Отображенные типы
```
interface Person {
  name: string;
  age: number;
}
```
Keyof также называется запросом индекса типа и предоставляет объединение допустимых имен свойств (ключей) заданного типа.
Если тип Person — это наш T, тогда keyof T предоставит объединение name и age.

> Readonly\<T> означает «Найти имена и типы свойств конкретного переданного типа и применить к каждому свойству
> квалификатор readonly».

```
function filterBy<T, P extends keyof T>( // Фильтрует массив обьектов по какому-либо полю
  property: P,                           // Свойство фильтра
  value: T[P],                           // Значение для фильтра должно иметь тип переданного свойства P
  P array: T[]) {

    return array.filter(item => item[property] === value);
}
```

В первую очередь фрагмент <T, P extends keyof T> сообщает, что наша функция принимает два обобщенных значения: T и P. 
Мы также добавили ограничение, что P extends keyof T. Другими словами, P должен быть одним из свойств переданного типа 
T. Если конкретный тип T будет Person, тогда P может быть либо name, либо age.

> Связанный тип — это общий тип, использующий объединение, созданное с помощью оператора keyof, для перебора ключей 
>одного типа в целях создания другого

```
type OptionsFlags<Type> = {
 [Property in keyof Type]: boolean
}
type FeatureFlags = {
 darkMode: () => void
 newUserProfile: () => void
}

// type FeatureOptions = { darkMode: boolean, newUserProfile: boolean }
type FeatureOptions = OptionsFlags<FeatureFlags> 
```
---
> `T extends U`
> Здесь extends U означает «наследует от U» или «является U». 
> Выражение T extends U означает, что значение типа T может быть присвоено переменной типа U.

----
### Блокчейн-приложениe
> Блокчейн является децентрализованным способом хранения неизменяемых данных.
>В блокчейне транзакции объединяются в блоки, которые затем проверяются и связываются в цепочку. Отсюда и происходит 
>термин блокчейн (blockchain).

Если в блокчейн нужно добавить записи новых транзакций, приложение создает новый блок, передаваемый узлам блокчейна 
(компьютерам) для проверки при помощи одного из алгоритмов (например, вычисления особого хеш-кода), используемого в 
системах блокчейн. Если блок оказывается действительным, то добавляется в блокчейн; в противном случае он отвергается.

Полные копии блокчейна хранятся в узлах одноранговой сети, которая может также включать и ваши компьютеры, если вы 
решите присоединиться к блокчейну. Один узел не означает один компьютер — вы можете владеть компьютерным кластером, 
представляющим один узел.

После добавления блока в цепочку его данные не могут быть изменены, так как данные в блокчейне являются неизменяемыми.

В своей основе блокчейн — это децентрализованный неизменяемый журнал учета, представленный коллекцией блоков. Блоки 
могут хранить любой тип данных, например информацию о денежных переводах, результатах голосования, медицинских записях
 и т. д. Каждый блок связан с предыдущим посредством хранения его хеш-значения.
 
Процесс, при котором хеш-функция генерирует одинаковый вывод для более чем одного ввода, называется коллизией.

Блок в блокчейне представлен хеш-значением, и очень важно, чтобы киберпреступники не могли заместить один блок другим, 
подготовив вредоносное содержимое, которое производит тот же хеш, что и действительный блок.

Вы можете рассматривать блок как запись, или журнал учета. Каждый блок в блокчейне содержит данные приложения, а также 
имеет временную метку, свое собственное хеш-значение и хеш-значение предыдущего блока. В очень простом 
(и легко взламываемом) блокчейне приложение для добавления в цепочку нового блока может выполнить следующие действия:

1. Найти хеш последнего добавленного блока и сохранить его как ссылку на предыдущий блок.
2. Сгенерировать хеш-значение для нового блока.
3. Представить этот новый блок блокчейну для проверки.

Деньги в криптовалютах (вроде биткоина) «производятся» в качестве стимула для людей (майнеров) решать математические 
задачи, требуемые конкретным блокчейном. Поскольку каждый новый блок должен быть одобрен другими майнерами, значит, 
чем больше майнеров, тем безопаснее блокчейн.

В нашем распределенном блокчейне мы хотим убедиться, что могут быть добавлены только блоки с конкретными хешами. 
Например, наш блокчейн может требовать, чтобы каждый хеш начинался с 0000. Хеш вычисляется на основе содержимого блока,
и он не будет начинаться с четырех нулей, если только кто-нибудь не найдет дополнительное значение, чтобы добавить его
к содержимому блока и в итоге произвести подобный хеш. Нахождение такого значения называется добычей блока.

Прежде чем новый блок добавляется в блокчейн, он передается всем узлам сети на обработку, и эти узлы, в свою очередь, 
начинают вычислять особое значение, которое производит допустимый хеш. Первый, кто находит такое значение, выигрывает.
Выигрывает что? Блокчейн может предложить вознаграждение. Например, в блокчейне биткоина преуспевший добытчик данных 
зарабатывает биткоины.

В криптографии число, которое может быть использовано только один раз, называется nonce.
Майнер должен потратить вычислительные ресурсы для нахождения nonce в качестве доказательства проделанной работы, 
являющейся необходимым условием для каждого блока при запросе на добавление его в блокчейн.

- Главный смысл блокчейна в том, что он предлагает децентрализованную обработку транзакций без опоры на единый орган 
управления.
- В блокчейне каждый блок идентифицируется по хеш-значению и привязывается к предыдущему блоку через хранение его 
хеш-значения.
- Прежде чем вставлять новый блок в блокчейн, каждому узлу, заинтересованному в вычислении приемлемого хеш-значения за 
награду, предлагается математическая задача. Когда мы говорим «узел», то имеем в виду компьютер, сеть или ферму, 
представляющую одного участника блокчейна.
- В криптографии число, которое может использоваться только один раз, называется nonce, и майнер данных для «добычи» 
nonce должен затратить вычислительные ресурсы — так он получит доказательство проделанной работы, которое необходимо 
для любого блока, чтобы быть рассмотренным на предмет добавления в блокчейн.
- В нашем примере блокчейн-приложения приемлемое хеш-значение должно было начинаться с пяти нулей, и мы вычислили nonce,
 чтобы гарантировать, что хеш блока действительно начинается с пяти нулей. Вычисление nonce требует времени, что 
 задерживает добавление нового блока в блокчейн, но может быть использовано как доказательство работы для награждения 
 узла блокчейна, вычислившего его раньше остальных.
 
 ---
 
 > Вы можете вставлять эмодзи в строки в macOS через нажатие Cmd-Ctrl-пробел, а в Windows 10 — через нажатие Win-. 
 (Win и точка) или Win-; (Win и точка с запятой)¯\_(ツ)_/¯

Цифровая валюта также может быть подделана. Например, мошенник может попытаться заплатить заданную сумму денег 
нескольким получателям. Предположим, у Джо есть только один биткоин, и он отправляет его Мэри (создавая блок с 
транзакцией «Джо Мэри 1»), а затем тут же отправляет один биткоин Алексу (создавая другой блок с транзакцией «Джо 
Алекс 1»). Таков пример атаки двойного расходования.

Биткоин и другие блокчейны реализуют механизмы для предотвращения подобных атак, применяя для этого согласованный 
процесс проверки каждого блока и разрешения конфликтов. В разделе 10.1 мы объясним правило длиннейшей цепочки, которое 
может использоваться для предотвращения добавления недействительных блоков.

295