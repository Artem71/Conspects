Алан Бьюли 2007

SQL - язык для формирования, манипулирования и извлечения данных из реляционной БД.

БД - это всего лишь набор взаимосвязанных данных

Одна из причин популярности реляционных БД в том, что будучи правильно спроектированными, они могут
оперировать гиганскими обьемами данных

В иерархической системе баз данных данные были представлены в виду одной или несколько древовидных
структур.
Сетевой бд представляют наборы записей и наборы связей, определяющих отношения между разными 
записями

Внешние ключи (в реляционных бд) служат той же цели что и линии, соединяющие сущности в иерархической 
и сетевых версиях представления данных. Это Один или более столбцов, которые можно совместно использовать 
для идентификации одной строки другой таблицы.

Процесс улучшения структуры базы данных с целью облегчения хранения всех независимых элементов данных
только в одном месте называется нормализацией

Результатом SQL-запроса является таблица

Способ выполнения SQL-выражения зависит от компонента механизма СУБД называемого оптимизатором. Работа
оптимизатора заключается в том, что бы рассмотреть SQL-выражение и с учетом конфигурации таблиц и 
доступных индексов принять решение о самом эффективном пути решения запроса (не всегда самом эффективном)

Символьные данные могут хранится как строки переменной или фиксированной длинны (строки фиксированной длины
справа дополняются пробелами) CHAR(20) - фиксированная длина; VARCHAR(20) - переменная длинна

Ограничения первичного ключа - (CONSTRAINT pk_person PRIMARY KEY (person_id)) - сообщает серверу БД, какой
столбец или столбцы будут играть роль первичного ключа

Ограничение внешнего ключа (CONSTRAINT fk_person_id FOREIGN KEY (person_id) REFERENCES person (person_id)) 
- ограничивает значения столбца person_id, позволяя ему включать только те значения которые есть в таблице 
person

----
Если при создании таблицы ограничение внешнего ключа не было указано, его можно добавить позже с помощью 
оператора alter table (изменить таблицу)
----

Для Mysql дату можно предоставить в виде строки если она соответствует формату «YYYY-MM-DD»

Блок ORDER BY указывает серверу, как сортировать данные, возвращаемые запросом. Без ORDER BY данные таблицы
будут извлечены в произвольном порядке.

Если опустить блок WHERE, то выражение UPDATE обновит все строки таблицы
------------------------

Как только сервер проверил логин/пароль он создает для нас соединение с БД. Это соединение удерживается
открытым, пока приложение не высвободит соединение (например командой quit) или пока соединение не будет
закрыто сервером (например при выключении сервера)
Каждому соединению с сервером Mysql присваивается уникальный идентификатор, предоставляемый пользователю
сразу после регистрации

В sql запросах существует 6 блоков (по крайней мере 1 обязательный, в mysql есть еще пара дополнительных)
Select - Определяет столбцы, которые должны быть включены в результирующий набор запроса
From - Указывает таблицы, из которых должны быть извлеченны данные, и то как эти таблицы должны быть соеденены
Where - Ограничивает число строк в окончательном результирующем наборе
Group by - Используется для группировки строк по одинаковым значения столбцов
Having - Ограничивает число строк в результирующей выборке с помощью группировки данных
Order by - Сортирует строки окончательного результирующего набора по одному или более столбцам


-----SELECT-----
Не смотря на то, что блок селект идет первым, сервер БД обрабатывает его одним из последних (что бы определить,
что нужно вытащить, нужно понять что вообще есть)

В блок селект можно добавить:
Литералы (числа или строки)
Выражения (transaction.amount * -1)
Вызовы встроенных функций, например ROUND(transaction.amount, 2)

Если требуется встроенную функцию или вычислить простое выражение, можно вообще обойтись без блока FROM
DISTINCT - сортирует данные возвращая только уникальные значения. Сортировка требует времени поэтому при запросе
больших данных лучше стараться избегать его (а лучше обдумывать запрос)


-----FROM-----
Блок фром определяет таблицы используемые запросом, а так же средства связывания таблиц

Подзапрос - запрос содержащийся в другом запросе (заключаются в круглые скобки)
В рамках блока фром подзапрос формирует временную таблицу, видимую для всех остальных блоках запроса, и способную
с ними взаимодействовать

Представление - запрос хранящийся в словаре данных. Оно выглядит и работает как таблица, но с представлением не
ассоциированны никакие данные (виртуальная таблица)
Представления создаются по разным причинам, в том числе и для того, что бы скрыть столбцы от пользователей и 
упростить сложно устроенны БД

-----GROUP BY & HAVING-----
Orber by - механизм сортировки результирующего набора на оснавании данных столбцов, или выражений, использующих
данные столбцов

----------------------------------------------
При работе с оператором between надо помнить что, первым (после оператора) всегда задается нижняя граница.
Нижняя и верхняя граница включаются в диапозон.

Символные маски:
- только один символ
% Любое число символов (F% - строка начинается с F, %t - строка заканчивается на t, %bas% - содержит подстроку)

Null - это отсутствие значения

------------------------------------------------
Перекресное соединение таблиц - это все возможные перестановки выбранных таблиц (JOIN)
Внутренее соединение (INNER JOIN) общие данные Если имена столбцов, используемых для соединения двух
таблиц, совпадают, можно вместо подблока ON применить подблок USNG (USING (dept_id))

Таблицу можно соединять с собой же

Операторы union (обьеденить) и union all (обьеденить все) позволяют комбинировать несколько таблиц.
Разница в том, что если требуется обьеденить две таблицы, включая в окончательный результат все их 
строки, даже дублирющие значения, нужно использовать оператор union all.

Операция except возвращает первую таблицу за вычетом всех перекрытий со второй таблицей.
Порядок разных операторов работы с множествами в составном запросе имеет значение.

Чтобы обеспечить общую точку отсчета для хронометрирования, мореплаватели XV столетия устанавливали свои часы 
по Гринвичу (Англия). Это время назвали временем по Гринвичу (Greenwich Mean Time), или GMT. Все остальные часовые 
пояса можно описать разностью между GMT и местным временем. Например, часовой пояс восточных штатов Америки, 
известный как восточное поясное время (Eastern Standard Time), можно описать как GMT5:00 (на пять часов раньше GMT).

last_day() (последний день)
date_add() позволяет добавить любой интервал (т. е. дни, месяцы, года) к заданной дате, чтобы получить другую дату
dayname() (название дня), на какой день недели приходится определенная дата
datediff()  возвращает количество полных дней между двумя датами
cast()  преобразования строки в значение типа datetime

------
агрегатную функцию нельзя включать в блок where. Причина в том, что фильтры блока обрабатываются до выполнения группировки,
поэтому серверу еще не доступны какие-либо действия над группами.

Агрегатные функции осуществляют определенную операцию над всеми строками группы.

При введении фильтров в запрос, включающий блок group by, необходимо тщательно продумать, к чему применяется фильтр –
к необработанным данным (тогда он относится к блоку where) или к сгруппированным данным (в этом случае он относится 
к блоку having)

Если подзапрос не использует ничего из содержащего запроса, то его называют несвязанным подзапросом
Если подзапрос возвращает одну строку и один столбец и при этом он не связанный то такой подзапрос называют скалярным

Связанный подзапрос, зависит от содержащего выражения, из которого он ссылается на один или более столбцов.

Внешнее соединение включает все строки одной таблицы и вводит данные второй таблицы только в случае обнаружения
соответствующих строк.

Ключевое слово left свидетельствует о том, что таблица, находящаяся в левой части блока from, отвечает за определение
числа строк в результирующем наборе, а таблица в правой части предоставляет значения столбцов в случае обнаружения
соответствия.
Ключевые слова left и right просто сообщают оптимизатору БД, какая таблица может иметь пробелы в данных.

Пользователи, осуществляющие запись в БД, должны запрашивать и получать от сервера блокировку записи (write lock) для изменения
данных. А пользователи, считывающие данные из БД, должны запрашивать и получать от сервера блокировку чтения (read lock)
для осуществления запросов к данным.

В транзакции можно установить одну или более точек сохранения (savepoints) и использовать их для отката к определенному месту 
транзакции, а не откатывать полностью к началу.

Индексы – это специальные таблицы, содержимое которых, в отличие от обычных таблиц данных, хранится в определенном порядке. 
Однако индекс включает не все данные сущности, а только столбец (или столбцы), используемый для опреде ления местоположения 
строк в таблице данных, а также информацию, описывающую физическое размещение строк. Поэтому предназначение индексов – помочь 
в извлечении подмножества строк и столбцов таблицы без необходимости проверять все строки.

Если индексы – это так замечательно, почему бы не индексировать все подряд? Чтобы понять, почему большее количество индексов не всегда
хорошо, надо помнить, что каждый индекс – это таблица (особого типа, но все равно таблица). Поэтому при каждом добавлении или удалении 
строки из таблицы все ее индексы должны быть модифицированы. При обновлении строки все задействованные индексы столбца или
столбцов тоже должны изменяться. Следовательно, чем больше индексов, тем больше работы приходится выполнять серверу для обновления 
всех объектов схемы. А это очень замедляет процесс.
Индексам требуется некоторое количество памяти, а также некоторое внимание администраторов, поэтому наилучшая стратегия – добавлять
индекс только при возникновении вполне определенной необходимости.

Ограничение – это просто некоторое ограничивающее условие, налагаемое на один или более столбцов таблицы. Есть несколько разных
типов ограничений, включая:
Ограничения первичного ключа (Primary key constraints)
Идентифицируют столбец или столбцы, гарантирующие уникальность в рамках таблицы.
Ограничения внешнего ключа (Foreignkey constraints)
На один или более столбцов накладывается такое ограничение: они могут содержать только значения, содержащиеся в столбцах 
первичного ключа другой таблицы. Также могут ограничиваться допустимые значения других таблиц, если установлены правила 
update cascade (каскадное обновление) или delete cascade (каскадное удаление).
Ограничения уникальности (Unique constraints)
На один или более столбцов накладывается ограничение: они могут содержать только уникальные в рамках таблицы значения.
Проверочные ограничения целостности (Check constraints)
Ограничивают допустимые значения столбца.