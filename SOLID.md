### SINGLE RESPONSIBILITY
> Принцип единой ответственности

1 сущность = 1 задача (сущьностью может быть класс, модуль, компонент)
У нас не должно быть (god object) обьектов которые что-то логируют, что-то записывают, что-то куда-то отправляет.
Когда одна сущность разрастается, она решает много задач, мы получаем много связанного кода. Ломается что-то одно -> 
ломается и что-то другое = трудно вносить изменения
Ухудшается читаемость

Стоит разделять модель данных от поведения

<hr>

### OPEN CLOSED
> Принци открытости/закрытости

Программные сущности должны быть открыты для расширения, но закрыты для изменения

Изменять существующий, работающий код это плохо! Потому что он протестирован, он работает, и у нас нет с ним проблем
Иначе нам нужна регрессия

Нам надо стараться добавлять новый функционал не за счет изменения старых сущностей, а за счет добавления новых. Для этого 
у нас есть композиция, наследование 

<hr>

### LISKOV SUBSTITUTION
> Принци подстановки барборы лисков

Функции, сущности которые используют родительский тип - должны точно так же работать и с дочерними классами при это ничего
не должно ломаться в логике работы программы, и она не должна нарушаться

т.е. наследуемый класс должен дополнять, а не замещать поведение базового класса

<hr>

### INTERFACE SEGREGATION
> Принцип разделения интерфейса

Программные сущности не должны зависить от методов которые они не используют 
(этот принцип тесно пересекается с сингл респонсобилити и прниципов подстановки)

Основная суть в том, что бы разбивать наши толстые интерфейсы, наши программные сущности на более маленькие, узкоспециалезированные,
решающие одну задачу

т.е. нельзя застовлять клиента реализоовать интерфейс которым он не пользуется

Делать общее решение это антипаттерн!

- Избавляем программные сущности от методов которые они не используют ->
- Получаем более предсказуемую работу ->
- Код становится менее связанным

Чем меньше связть между модулями - тем легче такое приложение поддерживать

<hr>

### DEPENDENCY INVERSION
> Принци инверсии зависимостей

Модули высокого уровня не должны зависеть от модулей более низкого уровня. Все они должны зависить от абстракций, а абстракции
не должны зависить от деталей. Детали должны зависить от абстракций

(заменив деталь в станке, мы не должны менять работников и электричество)

Создаем абстракции между двумя связанными модулями

<hr>

Итог:
- S - Для каждого модуля в нашей системе, одно значение. Все ресурсы для этого модуля инкапсулированны в нем же
- O - Новый функционал добавляем не путем переписывания старого функционала, а добавлением новых сущностей
- L - Обьекты в программе должны быть заменяемыми своими дочерними классами, и при это логика работы нарушаться не должна
- I - Много интерфейсов для одного клиента - гораздо лучше чем один общий. Класс не должен содержать в себе методов 
которые он не использует
- D - Зависимость строится на абстракции, и не зависит от чего-то конкретного