> Реакт это библиотека для создания пользовательских интерфейсов

> Реакт спроектирован таким образом, что он не зависим от браузера. Он живет сам по себе и отвечает за создание
> интерфейсов, а за визуализацию, отрисовку компонентов в браузер отвечает библиотека React DOM

> Через React native можно создавать приложения для android, IOS, и windows

<hr>

Первичную отрисовку (с загрузкой всего бандла, а он большой) можно потимизировать, применив различные хитрости - 
- Настройка webpack
- lazy-loading

<hr>

Проблема в прямой работе с DOM деревом в том, что разработчик больше думает о том, что куда добавить, что где получить,
что где удалить и это увеличивает вероятность ошибок и так же увеличивает время разработки приложений.
Плюс все операции над DOM деревом все ресурсоемкие и очень тяжелые, реакт же за счет своей концепций позволяет
созредотачиваться на логике работы с данными 

<hr>

Под капотом реакт строит виртуальное DOM-дерево (более легковесная копия обычного DOM в браузере). Так как реакт 
работает в разных окружениях, а DOM это про браузер, то сами разработчики предпочитают это называть Деревом Элементов.

Во время изменения элементов реакт не сразу применяет их, а создает новую версию дерева элементов и сравнивает её с 
предыдущей путем сложных алгоритмов. Эта стадия называется соглосованием (reconciliation). Согласовании выполняет ядро
реакта и оно не зависит от среды выполнения. 

После фазы согласования наступает фаза отрисовки (рендеринга), т.е. мы видим обновленные данные на странице. При этом
реакт каждому изменения устанавливает приоритетность (более приоритетные отрисоовываются быстрее, другие медление). За
счет этого мы видим более плавную картинку

<hr>

> HTML внутри JS файла это JSX синтаксис

<hr>

Когда мы в компоненте изменяем какую-либо переменную, реакт не понимает в каком компоненте произошли изменения. Для
этого необходимо явно сообщить, что вот тут мы изменяем такое то вот значение. Для этого придумано состояние. Т.е. у
каждого компонента есть какое-то состояние. И при изменении этого состояния, реакт понимает, что произошли какие-то
изменения и перерисовывает компонент (useStore - импортируется из либы реакта). Пример:

`const [count, setCount] = useState(0)` // useState возвращает массив с переменной и методом для её обновления


<strong>очень важная концепция в том, что мы не мутируем обьекты/массивы текущего состояния, а каждый раз прокидываем 
новые!!!</strong>

`setPosts([...posts, newPost])`

<hr>

Компоненты бывают классовые и функциональные. <b>Классовые компоненты это устаревший подход</b>. Разработчики 
рекомендуют функциональные компоненты и хуки

У каждого компонента есть 3 этапа жизненного цикла - монтирование, обновление, размонтирование

<hr>

> Хуки это некоторые функции которые предоставляет реакт. Эти функции всегда начинаются со слова `use`. При этом, хуки
> можно использовать либо в функциональных компонентах, либо в своих собственных хуках.

Т.е. мы можем на основании основных реакт хуков, делать свои с собственным функционалом. <b>При этом!!! Хуки можно 
использовать только на верхнем уровне вложенности (не можем вкладывать хуки в функции, либо в условия, в циклы). Только
на верхнем уровне вложенности компонента или кастомного хука</b>

<hr>

Работа с пропсами и ключами аналогична Vue. Только вместо эмита события с измененными пропсами, мы прокидываем колбек,
и уже через этот колбек меняем пропсы

<hr>

Пример итерации по массиву для рендера:

`
return (

    <div className="App">
        {posts.map((post) =>
            <PostItem post={post} key={post.id} />
        )}
    </div>
)
`

В компоненте может быть только один корневой элемент

<hr>

Для использования css модулей мы обзываем css файл  префиксом `module`, импортируем его как класс и прокидываем его в
классы элемента как свойство обьекта. Пример:


~~~
import classes from './some.module.css'

// some code

return (
    <div className={classes.myDiv}> // myDiv - название класса в css файле
        some content
    </div>
)
~~~

<hr>

Слоты прокидываются в компонент через пропс children. Пример:

`const MyButton = ({ children, ...props }) => {`

Для байнда аттрибутов мы пропсы разворачиваем на самом элементе. Пример:

`<button { ...props } className={classes.myDiv}>`

Для двухстороннего звязывания необходимо явно прокидывать события. Пример:

~~~
<MyInput
    value={title}
    onChange={e => setTitle(e.target.value)}
/>
~~~

Для использования рефов нам необходимо воспрользоваться хуком `useRef()` и дальше по аналогии с Vue. Пример:
~~~
const bodyInputRef = useRef()

// some code

<input ref={bodyInputRef}

Получить DOM элемент можно через - bodyInputRef.current
~~~
Для того, что бы использовать ref с кастомным компонентом, нам необходимо кастомный компонент обернуть в функцию
`React.ForwardRef()`, после этого мы вторым аргументом будем получать ссылку ref и уже её явно прокидывать на 
интересующий нам элемент. Пример:
~~~
const MyInput = React.ForwardRef((props, ref) => {
~~~ 

> Кастомный компонент в которые мы прокинули ref называется неуправляемым или неконтролируемым (без рефа управляемый) 

<hr>

`useMemo(callback, deps)` - аналог computed. Этот хук производит вычисления, запоминает результат и кеширует (такое 
поведение называет мемоизацией) и на каждую перерисовку компонента она не пересчитывает заного, она вытаскивает из кеша,
но когда изменяются зависимости она делает перерасчет

`useEffect(callback, deps)` - так же принимает колбек и массив зависимостей. (аналог watch)
- когда массив зависимостей пустой, колбек отработает единожды (когда компонент был вмонтирован). Так можно отследить
стадию монтирования
- если передадим какую либо переменную, то колбек будет вызываться каждый раз при её изменении
- если колбек возвращает функцию, то эта функция будет вызвана в момент демонтирования (анмаунт)